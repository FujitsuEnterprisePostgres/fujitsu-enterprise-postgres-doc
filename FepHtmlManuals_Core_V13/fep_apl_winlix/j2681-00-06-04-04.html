<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>6.4.3 Bulk INSERT</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-00-06-00-00.html">Chapter&nbsp;6 Embedded SQL in C</a> &gt; <a href="j2681-00-06-04-00.html">6.4 Application Development</a> &gt; 6.4.3 Bulk INSERT</div><div class="back_next"><a href="j2681-00-06-04-02.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-06-04-05.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="IDapl06N7">6.4.3 Bulk INSERT</h3><div class="body"><div class="textblock"><p>This section describes the bulk INSERT.</p><p></p></div><p class="subhead_1" id="IDapl06N8"><span class="em">Synopsis</span></p><div class="textblock"><pre>EXEC SQL [ AT <span class="i">conn </span>] [ FOR { <span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span><span class="i"> </span>| ARRAY_SIZE } ] 	INSERT INTO <span class="i">table</span><span class="i">N</span><span class="i">ame</span> [ ( <span class="i">col</span><span class="i">N</span><span class="i">ame</span> [, ...] ) ]	{ VALUES ( { <span class="i">expr</span> | DEFAULT } [, ...] ) [, ...] | <span class="i">query</span> }	[ RETURNING * | <span class="i">output</span><span class="i">E</span><span class="i">xpr</span> [ [ AS ] <span class="i">output</span><span class="i">N</span><span class="i">ame</span> ] [, ...] 	INTO <span class="i">output</span><span class="i">H</span><span class="i">ost</span><span class="i">V</span><span class="i">ar</span> [ [ INDICATOR ] <span class="i">indicator</span><span class="i">V</span><span class="i">ar </span> ]  [, ...] ];</pre></div><p class="subhead_1" id="IDapl06N9"><span class="em">Description</span></p><div class="textblock"><p>Bulk INSERT is a feature that inserts multiple rows of data in bulk.</p><p>By specifying the array host variable that stored the data in the VALUES clause of the INSERT statement, the data for each element in the array can be inserted in bulk. This feature is used by specifying the insertion count in the FOR clause immediately before the INSERT statement.</p><br><dl><dt class="em">FOR Clause</dt><dd><p>Specify the insertion count using numOfRows or ARRAY_SIZE in the FOR clause. The FOR clause can be specified only in the INSERT statement, not in other update statements.</p><dl><dt class="em">numOfRows and ARRAY_SIZE</dt><dd><p>Insertion processing will be executed only for the specified count. However, if the count is 1, it will be assumed that the FOR clause was omitted when the application is executed. In this case, proceed according to the INSERT specification in the PostgreSQL Documentation.</p><p>Specify the FOR clause as an integer host variable or as a literal.</p><p>Specify ARRAY_SIZE to insert all elements of the array in the table. When specifying ARRAY_SIZE, specify at least one array in <span class="i">expr</span>.</p><p>If two or more arrays were specified in expr, it will be assumed that ARRAY_SIZE is the minimum number of elements in the array.</p><p><span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span> or ARRAY_SIZE must exceed the minimum number of elements in all arrays specified in <span class="i">expr</span>, <span class="i">output</span><span class="i">H</span><span class="i">ost</span><span class="i">V</span><span class="i">ar</span>, and <span class="i">indicator</span><span class="i">V</span><span class="i">al</span>.</p><br></dd></dl><p>The following example shows how to specify the FOR clause.</p><pre class="border">int  number_of_rows = 10;int id[25];char name[25][10]; EXEC SQL FOR :number_of_rows	/* will process 10 rows */INSERT INTO prod (name, id) VALUES (:name, :id); EXEC SQL FOR ARRAY_SIZE   		/* will process 25 rows */ INSERT INTO prod (name, id) VALUES (:name, :id); </pre></dd></dl><dl><dt class="em">expr</dt><dd><p>Specify the value to be inserted in the table. Array host variables, host variable literals, strings, and pointer variables can be specified. Structure type arrays and pointer variable arrays cannot be specified.</p><p>Do not use pointer variables and ARRAY_SIZE at the same time. The reason for this is that the number of elements in the area represented by the pointer variable cannot be determined.</p></dd></dl><dl><dt class="em">query</dt><dd><p>A query (SELECT statement) that supplies the rows to be inserted. The number of rows returned by <span class="i">query</span> must be 1. If two or more rows are returned, an error will occur. This cannot be used at the same time as ARRAY_SIZE.</p></dd></dl><dl><dt class="em">outputHostVar, indicatorVal</dt><dd><p>These must be array host variables or pointer variables.</p></dd></dl></div><p class="subhead_1" id="IDapl06N10"><span class="em">Error Messages</span></p><div class="textblock"><p>Given below are the error messages that are output when bulk INSERT functionality is not used correctly.</p><p id="N32M" class="message"><span class="em">invalid statement name "FOR value should be positive integer"</span></p><div class="textblock"><dl><dt class="em">Cause</dt><dd><p>The value given for <span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span> is less than or equal to 0.</p></dd></dl><dl><dt class="em">Solution</dt><dd><p>Specify a value that is more than or equal to 1 for <span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span>.</p></dd></dl></div><p class="msgtopic">Message</p><div class="textblock"></div><p id="N33M" class="message"><span class="em">invalid statement name "Host array variable is needed when using FOR ARRAY_SIZE"</span></p><div class="textblock"><dl><dt class="em">Cause</dt><dd><p>A host array is not specified in the values clause when using the ARRAY_SIZE keyword. </p></dd></dl><dl><dt class="em">Solution</dt><dd><p>At least one host array variable should be included in the values clause </p></dd></dl></div><p class="msgtopic">Message</p><div class="textblock"></div><p id="N34M" class="message"><span class="em">SELECT...INTO returns too many rows</span></p><div class="textblock"><dl><dt class="em">Cause</dt><dd><p>The number of rows returned by the 'SELECT ... INTO' query in the INSERT statement is more than one. </p></dd></dl><dl><dt class="em">Solution</dt><dd><p>When the value of <span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span> is more than one, the maximum number of rows that can be returned by the 'SELECT ... INTO' query in the INSERT statement is one.</p></dd></dl></div></div><p class="subhead_1" id="IDapl06N11">Message</p><div class="textblock"></div><p class="subhead_1" id="IDapl06N14"><span class="em">Limitations</span></p><div class="textblock"><p>The limitations when using bulk INSERT are given below.</p><ul><li><p>Array of structures should not be used as an input in the 'VALUES' clause. Attempted use will result in junk data being inserted into the table.</p></li><li><p>Array of pointers should not be used as an input in the 'VALUES' clause. Attempted use will result in junk data being inserted into the table.</p></li><li><p>ECPG supports the use of 'WITH' clause in single INSERT statements. 'WITH' clause cannot be used in bulk INSERT statements. </p></li><li><p>ECPG does not calculate the size of the pointer variable. So when a pointer variable is used that includes multiple elements, <span class="i">num</span><span class="i">O</span><span class="i">f</span><span class="i">R</span><span class="i">ows</span> should be less than or equal to the number of elements in the pointer. Otherwise, junk data will be inserted into the table.</p></li><li><p>If an error occurs, all bulk INSERT actions will be rolled back, therefore, no rows are inserted. However, if the RETURNING clause was used, and the error occurred while obtaining the rows after the insertion was successful, the insertion processing will not be rolled back.</p></li></ul></div><p class="subhead_1" id="IDapl06N15"><span class="em">Samples</span></p><div class="textblock"><p>Given below are some sample usages of the bulk INSERT functionality.</p><dl><dt class="em">Basic Bulk INSERT</dt><dd><pre class="border">int in_f1[4] = {1,2,3,4};...EXEC SQL FOR 3 INSERT INTO target (f1) VALUES (:in_f1);</pre><p>The number of rows to insert indicated by the FOR clause is 3, so the data in the first 3 elements of the host array variable are inserted into the table. The contents of the target table will be:</p><pre class="border"> f1 ----  1  2  3(3 rows)</pre><br><p>Also a host integer variable can be used to indicate the number of rows that will be inserted in FOR clause, which will produce the same result as above:</p><pre class="border">int num = 3;int in_f1[4] = {1,2,3,4};...EXEC SQL FOR :num INSERT INTO target (f1) VALUES (:in_f1);</pre><br></dd></dl><dl><dt class="em">Inserting constant values</dt><dd><p>Constant values can also be bulk INSERTed into the table as follows:</p><pre class="border">EXEC SQL FOR 3 INSERT INTO target (f1,f2) VALUES (DEFAULT,'hello');</pre><p>Assuming the 'DEFAULT' value for the 'f1' column is '0', the contents of the target table will be:</p><pre class="border">f1 |  f2   ---+------- 0 | hello 0 | hello 0 | hello(3 rows)</pre><br></dd></dl><dl><dt class="em">Using ARRAY_SIZE</dt><dd><p>'FOR ARRAY_SIZE' can be used to insert the entire contents of a host array variable, without explicitly specifying the size, into the table. </p><pre class="border">	int in_f1[4] = {1,2,3,4};...EXEC SQL FOR ARRAY_SIZE INSERT INTO target (f1) VALUES (:in_f1);</pre><p>In the above example, four rows are inserted into the table.</p><div class="note"><p class="title">Note</p><div class="notebody"><p>If there are multiple host array variables specified as input values, then the number of rows inserted is same as the smallest array size. The example given below demonstrates this usage.</p><pre class="border">int in_f1[4] = {1,2,3,4};char in_f3[3][10] = {"one", "two", "three"};...EXEC SQL FOR ARRAY_SIZE INSERT INTO target (f1,f3) VALUES (:in_f1,:in_f3);</pre><p>In the above example, the array sizes are 3 and 4. Given that the smallest array size is 3, only three rows are inserted into the table. The table contents are given below.</p><pre class="border"> f1 |  f3   ----+-------  1 | one  2 | two  3 | three(3 rows)</pre></div></div><br></dd></dl><dl><dt class="em">Using Pointers as Input</dt><dd><p>Pointers that contain multiple elements can be used in bulk INSERT. </p><pre class="border">int *in_pf1 = NULL;in_pf1 = (int*)malloc(4*sizeof(int));in_pf1[0]=1; in_pf1[1]=2; in_pf1[2]=3; in_pf1[3]=4; ...EXEC SQL FOR 4 INSERT INTO target (f1) values (:in_pf1);</pre><p>The above example will insert four rows into the target table.</p><br></dd></dl><dl><dt class="em">Using SELECT query</dt><dd><p>When using bulk INSERT, the input values can be got from the results of a SELECT statement. For example,</p><pre class="border">EXEC SQL FOR 4 INSERT INTO target(f1) SELECT age FROM source WHERE name LIKE 'foo';</pre><p>Assuming that the 'SELECT' query returns one row, the same row will be inserted into the target table four times. </p><div class="note"><p class="title">Note</p><div class="notebody"><p>If the 'SELECT' query returns more than one row, the INSERT statement will throw an error.</p><pre class="border">EXEC SQL FOR 1 INSERT INTO target(f1) SELECT age FROM source;</pre><p>In the above example, all the rows returned by the 'SELECT' statement will be inserted into the table. In this context '1' has the meaning of 'returned row equivalent'.</p></div></div><br></dd></dl><dl><dt class="em">Using RETURNING clause</dt><dd><p>Bulk INSERT supports the same RETURNING clause syntax as normal INSERT. An example is given below.</p><pre class="border">int out_f1[4];int in_f1[4] = {1,2,3,4};...EXEC SQL FOR 3 INSERT INTO target (f1) VALUES (:in_f1) RETURNING f1 INTO :out_f1;</pre><p>After the execution of the above INSERT statement, the 'out_f1' array will have 3 elements with the values of '1','2' and '3'.</p></dd></dl></div></div><div class="header_footer"><div class="back_next"><a href="j2681-00-06-04-02.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-06-04-05.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>