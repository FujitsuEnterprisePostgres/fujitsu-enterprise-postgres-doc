<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>D.6.1 Named SQL Descriptor Areas</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-d-00-00.html">Appendix&nbsp;D ECOBPG - Embedded SQL in COBOL</a> &gt; <a href="j2681-d-06-00.html">D.6 Using Descriptor Areas</a> &gt; D.6.1 Named SQL Descriptor Areas</div><div class="back_next"><a href="j2681-d-06-00.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-07-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_0e0601">D.6.1 Named SQL Descriptor Areas</h3><div class="body"><div class="textblock"><p>A named SQL descriptor area consists of a header, which contains information concerning the entire descriptor, and one or more item descriptor areas, which basically each describe one column in the result row.</p><p>Before you can use an SQL descriptor area, you need to allocate one:</p><pre class="border">EXEC SQL ALLOCATE DESCRIPTOR identifier END-EXEC.</pre><p>The identifier serves as the "variable name" of the descriptor area. When you don't need the descriptor anymore, you should deallocate it:</p><pre class="border">EXEC SQL DEALLOCATE DESCRIPTOR identifier END-EXEC.</pre><p>To use a descriptor area, specify it as the storage target in an INTO clause, instead of listing host variables:</p><pre class="border">EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc END-EXEC.</pre><p>If the result set is empty, the Descriptor Area will still contain the metadata from the query, i.e. the field names.</p><p>For not yet executed prepared queries, the DESCRIBE statement can be used to get the metadata of the result set:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 SQL-STMT PIC X(30) VARYING.EXEC SQL END DECLARE SECTION END-EXEC.MOVE "SELECT * FROM table1" TO ARR OF SQL-STMT.COMPUTE LEN OF SQL-STMT = FUNCTION STORED-CHAR-LENGTH ( ARR OF SQL-STMT ) .EXEC SQL PREPARE STMT1 FROM :SQL-STMT END-EXEC.EXEC SQL DESCRIBE STMT1 INTO SQL DESCRIPTOR MYDESC END-EXEC.</pre><p>Before PostgreSQL 9.0, the SQL keyword was optional, so using DESCRIPTOR and SQL DESCRIPTOR produced named SQL Descriptor Areas. Now it is mandatory, omitting the SQL keyword is regarded as the syntax that produces SQLDA Descriptor Areas. However, ecobpg does not support SQLDA and it causes an error.</p><p>In DESCRIBE and FETCH statements, the INTO and USING keywords can be used to similarly: they produce the result set and the metadata in a Descriptor Area.</p><p>Now how do you get the data out of the descriptor area? You can think of the descriptor area as a group item with named fields. To retrieve the value of a field from the header and store it into a host variable, use the following command:</p><pre class="border">EXEC SQL GET DESCRIPTOR name :hostvar = field END-EXEC.</pre><p>Currently, there is only one header field defined: COUNT, which tells how many item descriptor areas exist (that is, how many columns are contained in the result). The host variable needs to be of an integer type as PIC S9(9) COMP-5. To get a field from the item descriptor area, use the following command:</p><pre class="border">EXEC SQL GET DESCRIPTOR name VALUE num :hostvar = field END-EXEC.</pre><p>num can be a host variable containing an integer as PIC S9(9) COMP-5.<br>hostvar must be PIC S9(9) COMP-5 if type of the field is integer. Possible fields are:</p><dl><dt class="em">CARDINALITY (integer)</dt><dd><p>number of rows in the result set</p></dd></dl><dl><dt class="em">DATA</dt><dd><p>actual data item (therefore, the data type of this field depends on the query)</p></dd></dl><dl><dt class="em">DATETIME_INTERVAL_CODE (integer)</dt><dd><p>When TYPE is 9, DATETIME_INTERVAL_CODE will have a value of 1 for DATE, 2 for TIME, 3 for TIMESTAMP, 4 for TIME WITH TIME ZONE, or 5 for TIMESTAMP WITH TIME ZONE.</p></dd></dl><dl><dt class="em">DATETIME_INTERVAL_PRECISION (integer)</dt><dd><p>not implemented</p></dd></dl><dl><dt class="em">INDICATOR (integer)</dt><dd><p>the indicator (indicating a null value or a value truncation)</p></dd></dl><dl><dt class="em">KEY_MEMBER (integer)</dt><dd><p>not implemented</p></dd></dl><dl><dt class="em">LENGTH (integer)</dt><dd><p>length of the datum in characters</p></dd></dl><dl><dt class="em">NAME (string)</dt><dd><p>name of the column</p></dd></dl><dl><dt class="em">NULLABLE (integer)</dt><dd><p>not implemented</p></dd></dl><dl><dt class="em">OCTET_LENGTH (integer)</dt><dd><p>length of the character representation of the datum in bytes</p></dd></dl><dl><dt class="em">PRECISION (integer)</dt><dd><p>precision (for type numeric)</p></dd></dl><dl><dt class="em">RETURNED_LENGTH (integer)</dt><dd><p>length of the datum in characters</p></dd></dl><dl><dt class="em">RETURNED_OCTET_LENGTH (integer)</dt><dd><p>length of the character representation of the datum in bytes</p></dd></dl><dl><dt class="em">SCALE (integer)</dt><dd><p>scale (for type numeric)</p></dd></dl><dl><dt class="em">TYPE (integer)</dt><dd><p>numeric code of the data type of the column</p><br></dd></dl><p>In EXECUTE, DECLARE and OPEN statements, the effect of the INTO and USING keywords are different. A Descriptor Area can also be manually built to provide the input parameters for a query or a cursor and USING SQL DESCRIPTOR name is the way to pass the input parameters into a parametrized query. The statement to build a named SQL Descriptor Area is below:</p><pre class="border">EXEC SQL SET DESCRIPTOR name VALUE num field = :hostvar END-EXEC.</pre><p>PostgreSQL supports retrieving more than one record in one FETCH statement and storing the data in host variables in this case assumes that the variable is an array. E.g.:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 GROUP-ITEM.    05 IDNUM PIC S9(9) COMP OCCURS 5.EXEC SQL END DECLARE SECTION END-EXEC.EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc END-EXEC.EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :IDNUM = DATA END-EXEC.</pre><p></p></div></div><div class="header_footer"><div class="back_next"><a href="j2681-d-06-00.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-07-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>