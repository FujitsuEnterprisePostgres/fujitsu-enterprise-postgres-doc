<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>D.3.4 Prepared Statements</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-d-00-00.html">Appendix&nbsp;D ECOBPG - Embedded SQL in COBOL</a> &gt; <a href="j2681-d-03-00.html">D.3 Running SQL Commands</a> &gt; D.3.4 Prepared Statements</div><div class="back_next"><a href="j2681-d-03-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_0e0304">D.3.4 Prepared Statements</h3><div class="body"><div class="textblock"><p>When the values to be passed to an SQL statement are not known at compile time, or the same statement is going to be used many times, then prepared statements can be useful.</p><p>The statement is prepared using the command PREPARE. For the values that are not known yet, use the placeholder "?":</p><pre class="border">EXEC SQL PREPARE stmt1 FROM "SELECT oid, datname FROM pg_database WHERE oid = ?" END-EXEC.</pre><p>If a statement returns a single row, the application can call EXECUTE after PREPARE to execute the statement, supplying the actual values for the placeholders with a USING clause:</p><pre class="border">EXEC SQL EXECUTE stmt1 INTO :dboid, :dbname USING 1 END-EXEC.</pre><p>If a statement returns multiple rows, the application can use a cursor declared based on the prepared statement. To bind input parameters, the cursor must be opened with a USING clause:</p><pre class="border">EXEC SQL PREPARE stmt1 FROM "SELECT oid,datname FROM pg_database WHERE oid &gt; ?" END-EXEC.EXEC SQL DECLARE foo_bar CURSOR FOR stmt1 END-EXEC.* when end of result set reached, break out of while loop EXEC SQL WHENEVER NOT FOUND GOTO FETCH-END END-EXEC.EXEC SQL OPEN foo_bar USING 100 END-EXEC....PERFORM NO LIMIT    EXEC SQL FETCH NEXT FROM foo_bar INTO :dboid, :dbname END-EXECEND-PERFORM.FETCH-END.EXEC SQL CLOSE foo_bar END-EXEC.</pre><p>When you don't need the prepared statement anymore, you should deallocate it:</p><pre class="border">EXEC SQL DEALLOCATE PREPARE name END-EXEC.</pre><p>For more details about PREPARE, see "<a href="j2681-d-11-10.html">D.11.10 PREPARE</a>". Also see "<a href="j2681-d-05-00.html">D.5 Dynamic SQL</a>" for more details about using placeholders and input parameters.</p><p></p></div></div><div class="header_footer"><div class="back_next"><a href="j2681-d-03-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>