<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>4.4.4 Notes</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-00-04-00-00.html">Chapter&nbsp;4 .NET Data Provider</a> &gt; <a href="j2681-00-04-04-00.html">4.4 Application Development</a> &gt; 4.4.4 Notes</div><div class="back_next"><a href="j2681-00-04-04-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-04-05-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_040405">4.4.4 Notes</h3><div class="body"><div class="textblock"><p></p></div><p class="subhead_1" id="IDapl04N5"><span class="em">Notes on TableAdapter</span><a name="N14G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>If [SELECT which returns a single value] is selected when adding a query to a TableAdapter, it will not be possible to execute the SQL statement displayed on the window - therefore, correct the SQL statement.</p></li></ul></div><p class="subhead_1" id="mID_040404_plugin"><span class="em">Type Plugins</span><a name="N15G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>These type libraries include: </p><ul><li><p>NodaTime - the recommended way to interact with PostgrSQL date/time types</p></li><li><p>Json.NET - allows Npgsql to use the NewtonSoft Json.NET library when reading and writing JSON data (both json and jsonb) </p></li><li><p>NetTopologySuite - allows Npgsql to map PostGIS spatial types directly to the NetTopology suite types (the leading spatial library in .NET)</p></li><li><p>GeoJSON - allows Npgsql to read and write PostGIS spatial types as GeoJSON types via the GeoJSON.NET library</p></li><li><p>LegacyPostgis - implements the previously supported PostGIS spatial types as a plugin and is limited to geometry and XY only. Gerography and XYZ, XYM and XYZM is not supported in this plugin and if required, use the NetTopologySuite plugin</p></li><li><p>RawPostgis - allows raw byte access to PostGIS types</p></li></ul></li><li><p>Setup the plugin in your application simply by adding a dependency on the plugin (this should have been done automatically when installed to the project) and set it up. See the following code snippet for an example of setting up the Npgsql.NodaTime plugin:</p><pre class="border">	using Npgsql;	// Place this at the beginning of your program to use NodaTime everywhere (recommended)	NpgsqlConnection.GlobalTypeMapper.UseNodaTime();	// Or to temporarily use NodaTime on a single connection only:	conn.TypeMapper.UseNodaTime();</pre><p>Once the plugin is setup, you can read and write NodaTime objects as per the code snippet below:</p><pre class="border">	// Write NodaTime Instant to PostgreSQL "timestamp without time zone"	using (var cmd = new NpgsqlCommand(@"INSERT INTO mytable (my_timestamp) VALUES (@p)", conn))	{	    cmd.Parameters.Add(new NpgsqlParameter("p", Instant.FromUtc(2011, 1, 1, 10, 30)));	    cmd.ExecuteNonQuery();	}		// Read timestamp back from the database as an Instant	using (var cmd = new NpgsqlCommand(@"SELECT my_timestamp FROM mytable", conn))	using (var reader = cmd.ExecuteReader())	{	    reader.Read();	    var instant = reader.GetFieldValue&lt;Instant&gt;(0);	}</pre></li></ul><ul><li><p>To apply the type plugin updates, do one of the following:</p><ul><li><p>After uninstalling the type plugin (Refer to "<a href="j2681-00-04-05-02.html">4.5.2 Uninstalling .NET Data Provider Type Plugins</a>"), setup the type plugin (Refer to "<a href="j2681-00-04-02-03.html">4.2.3 Setting Up .NET Data Provider Type Plugins</a><span class="em">")</span><span class="em">.</span></p></li><li><p>Remove the type plugin directory from the packages directory of the solution, and then restore it using the nuget restore command.</p></li></ul></li><li><p>When you deploy an application with a type plugin, the type plugin is included in the distribution. Therefore, after applying the type plugin updates, you must rebuild the application and deploy the updated application.</p></li></ul></div><p class="subhead_1" id="mID_040404_plugin_note"><span class="em">Additional Notes on each Type Plugin</span><a name="N16G"></a></p><div class="textblock"><p>Describe notes about each type plugin.</p><dl><dt class="em">NodaTime</dt><dd><dl><dt class="em">Mapping Table </dt><dd></dd></dl><p>Describes the mapping of PostgreSQL data types to NodaTime data types.</p><table><col><col><col><col><tr><th valign="top"><p><span class="em">PostgreSQL</span><span class="em"> </span><span class="em"><br>Type</span></p></th><th valign="top"><p><span class="em">Default</span><span class="em"><br>NodaTime Type</span></p></th><th valign="top"><p><span class="em">Additional</span><span class="em"><br>NodaTime Type</span></p></th><th valign="top"><p><span class="em">Note</span></p></th></tr><tr><td align="left" valign="top"><p>timestamp</p></td><td align="left" valign="top"><p>Instant</p></td><td align="left" valign="top"><p>LocalDateTime</p></td><td align="left" valign="top"><p>It's common to store UTC timestamps in databases - you can simply do so and read/write Instant values. You also have the option of readin/writing LocalDateTime, which is a date/time with no information about timezones; this makes sense if you're storing the timezone in a different column and want to read both into a NodaTime ZonedDateTime</p></td></tr><tr><td align="left" valign="top"><p>timestamp with time zone</p></td><td align="left" valign="top"><p>Instant</p></td><td align="left" valign="top"><p>ZonedDateTime, OffsetDateTime</p></td><td align="left" valign="top"><p>This PostgreSQL type stores only a timestamp, assumed to be in UTC. If you read/write this as an Instant, it will be provided as stored with no timezone conversions whatsoever. If, however, you read/write as a ZonedDateTime or OffsetDateTime, the plugin will automatically convert to and from UTC according to your PostgreSQL session's timezone.</p></td></tr><tr><td align="left" valign="top"><p>date</p></td><td align="left" valign="top"><p>LocalDate</p></td><td align="left" valign="top"></td><td align="left" valign="top"><p>A simple date with no timezone or offset information.</p></td></tr><tr><td align="left" valign="top"><p>time</p></td><td align="left" valign="top"><p>LocalTime</p></td><td align="left" valign="top"></td><td align="left" valign="top"><p>A simple time-of-day, with no timezone or offset information.</p></td></tr><tr><td align="left" valign="top"><p>time with time zone</p></td><td align="left" valign="top"><p>OffsetTime</p></td><td align="left" valign="top"></td><td align="left" valign="top"><p>This is a PostgreSQL type that stores a time and an offset.</p></td></tr><tr><td align="left" valign="top"><p>interval</p></td><td align="left" valign="top"><p>Period</p></td><td align="left" valign="top"></td><td align="left" valign="top"><p>This is a human interval which does not have a fixed absolute length ("two months" can vary depending on the months in question), and so it is mapped to NodaTime's Period (and not Duration or TimeSpan).</p></td></tr></table><br></dd></dl><dl><dt class="em">Json.NET</dt><dd><p>Once the JSON plugin has been setup, users can transparently read and write CLR objects as JSON values and the plugin will automatically serialize/deserialize them</p><p>See the code snippet below:</p><pre class="border">// Write arbitrary CLR types as JSONusing (var cmd = new NpgsqlCommand(@"INSERT INTO mytable (my_json_column) VALUES (@p)", conn)){    cmd.Parameters.Add(new NpgsqlParameter("p", NpgsqlDbType.Jsonb) { Value = MyClrType });    cmd.ExecuteNonQuery();}// Read arbitrary CLR types as JSONusing (var cmd = new NpgsqlCommand(@"SELECT my_json_column FROM mytable", conn))using (var reader = cmd.ExecuteReader()){    reader.Read();    var someValue = reader.GetFieldValue&lt;MyClrType&gt;(0);}</pre><br></dd></dl><dl><dt class="em">NetTopologySuite (spatial)</dt><dd><p>By default the plugin handles only ordinates provided by the DefaultCoordinateSequenceFactory of GeometryServiceProvider.Instance. If GeometryServiceProvider is initialized automatically the X and Y ordinates are handled. To change the behavior specify the handleOrdinates parameter like in the following example:</p><pre class="border">conn.TypeMapper.UseNetTopologySuite(handleOrdinates: Ordinates.XYZ);</pre><p>To process the M ordinate, you must initialize GeometryServiceProvider.Instance to a new NtsGeometryServices instance with coordinateSequenceFactory set to a DotSpatialAffineCoordinateSequenceFactory. Or you can specify the factory when calling UseNetTopologySuite.</p><pre class="border">// Place this at the beginning of your program to use the specified settings everywhere (recommended)GeometryServiceProvider.Instance = new NtsGeometryServices(    new DotSpatialAffineCoordinateSequenceFactory(Ordinates.XYM),    new PrecisionModel(PrecisionModels.Floating),    -1);// Or specify settings for Npgsql onlyconn.TypeMapper.UseNetTopologySuite(    new DotSpatialAffineCoordinateSequenceFactory(Ordinates.XYM));</pre><br><dl><dt class="em">Reading and Writing Geometry Values</dt><dd><p>When reading PostGIS values from the database, Npgsql will automatically return the appropriate NetTopologySuite types: Point, LineString, and so on. Npgsql will also automatically recognize NetTopologySuite's types in parameters, and will automatically send the corresponding PostGIS type to the database. The following code demonstrates a roundtrip of a NetTopologySuite Point to the database:</p><pre class="border">var point = new Point(new Coordinate(1d, 1d));conn.ExecuteNonQuery("CREATE TEMP TABLE data (geom GEOMETRY)");using (var cmd = new NpgsqlCommand("INSERT INTO data (geom) VALUES (@p)", conn)){    cmd.Parameters.AddWithValue("@p", point);    cmd.ExecuteNonQuery();}using (var cmd = new NpgsqlCommand("SELECT geom FROM data", conn))using (var reader = cmd.ExecuteReader()){    reader.Read();    Assert.That(reader[0], Is.EqualTo(point));}</pre><p>You may also explicitly specify a parameter's type by setting NpgsqlDbType.Geometry.</p><br></dd></dl><dl><dt class="em">Geography (geodetic) Support</dt><dd><p>PostGIS has two types:geometry (for Cartesian coordinates) and geography (for geodetic or spherical coordinates). You can read about the geometry/geography distinction in the PostGIS docs. In a nutshell, geography is much more accurate when doing calculations over long distances, but is more expensive computationally and supports only a small subset of the spatial operations supported by geometry.</p><p>Npgsql uses the same NetTopologySuite types to represent both geometry and geography - the Point type represents a point in either Cartesian or geodetic space. You usually don't need to worry about this distinction because PostgreSQL will usually cast types back and forth as needed. However, it's worth noting that Npgsql sends Cartesian geometry by default, because that's the usual requirement. You have the option of telling Npgsql to send geography instead by specifying NpgsqlDbType.Geography:</p><pre class="border">using (var cmd = new NpgsqlCommand("INSERT INTO data (geog) VALUES (@p)", conn)){    cmd.Parameters.AddWithValue("@p", NpgsqlDbType.Geography, point);    cmd.ExecuteNonQuery();}</pre><p>If you prefer to use geography everywhere by default, you can also specify that when setting up the plugin:</p><pre class="border">NpgsqlConnection.GlobalTypeMapper.UseNetTopologySuite(geographyAsDefault: true);</pre><br></dd></dl></dd></dl><dl><dt class="em">GeoJSON (spatial)</dt><dd><p>Using the GeoJSON plugin is the same as the NetTopologuSuite.</p><br></dd></dl><dl><dt class="em">LegacyPostgis (spatial)</dt><dd><p>If you've used the internal PostGIS types in Npgsql 3.2 or earlier, the plugin works in the same way:</p><pre class="border">NpgsqlConnection.GlobalTypeMapper.UseLegacyPostgis();// Writevar cmd = new NpgsqlCommand("INSERT INTO table (pg_point, pg_polygon) VALUES (@point, @polygon)", conn);cmd.Parameters.AddWithValue("point", new PostgisPoint(3.5, 4.5));cmd.ExecuteNonQuery();// Readvar cmd = new NpgsqlCommand("SELECT * FROM table", conn);var reader = cmd.ExecuteReader();while (reader.Read()) {    var point = reader.GetFieldValue&lt;PostgisPoint&gt;(0);    var polygon = reader.GetFieldValue&lt;PostgisPolygon&gt;(1);}</pre></dd></dl></div><p class="subhead_1" id="IDapl04N6"><span class="em">Notes on the </span><span class="em">Q</span><span class="em">uery </span><span class="em">B</span><span class="em">uilder</span><a name="N17G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>Prefix named parameters with "@". </p></li><li><p>Uppercase object names cannot be used, even when enclosed in double quotation marks.<br>To use uppercase object names enclosed in double quotation marks, include them in SQL statements and enter these in the [Generate the SQL statements] window rather than in the Query Builder.</p></li><li><p>SQL statements cannot be correctly generated if the SQL statement specified in Filter matches any of the conditions below:</p><ul><li><p>It uses PostgreSQL intrinsic operators such as &lt;&lt; or ::.</p></li><li><p>It uses functions with keywords such as AS, FROM, IN, OVER.</p><p>Example: extract(field from timestamp), RANK( ) OVER</p></li><li><p>It uses functions with the same names as those prescribed in SQL conventions, but that require different arguments.</p></li></ul></li></ul></div><p class="subhead_1" id="IDapl04N7"><span class="em">Notes on Server Explorer</span><a name="N18G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>The temporary table is not displayed.</p></li></ul></div><p class="subhead_1" id="IDapl04N8"><span class="em">Notes on </span><span class="em">metadata</span><a name="N19G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>The CommandBehavior.KeyInfo argument must be specified if executing ExecuteReader before obtaining metadata using GetSchemaTable.</p><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">NpgsqlDataReader  ndr=cmd.ExecuteReader(CommandBehavior.KeyInfo);DataTable dt = dr.GetSchemaTable();</pre></div></div></li></ul></div><p class="subhead_1" id="IDapl04N9"><span class="em">Notes on automatically generating update-type </span><span class="em">SQL statements</span><a name="N20G"></a><span class="em"></span></p><div class="textblock"><ul><li><p>If the SQL statement includes a query (which cannot be updated) that matches any of the conditions below, an update-type SQL statement will be generated (note that it may not be possible to execute this SQL statement in some cases):</p><ul><li><p>It includes derived tables</p></li><li><p>It includes the same column name as the select list</p><br></li></ul><p>Update-type SQL statements will be automatically generated in the following cases:</p><ul><li><p>If update statements are obtained using NpgsqlCommandBuilder</p></li><li><p>If data is updated using NpgsqlDataAdapter</p></li><li><p>If data is updated using TableAdapter</p></li></ul></li></ul></div><p class="subhead_1" id="IDapl04N10"><span class="em">Notes on distributed transactions</span></p><div class="textblock"><ul><li><p>Applications using transaction scope can use distributed transactions by linking with Microsoft Distributed Transaction Coordinator (MSDTC). In this case, note the following:</p><ul><li><p>Ensure that the value of max_prepared_transactions is greater than max_connection, so that "PREPARE TRANSACTION" can be issued for each transaction that simultaneously connects to the database server.</p></li><li><p>If each transaction in the transaction scope accesses the same resource using different connections, the database server will perceive it as requests from different applications, and a deadlock may occur. By configuring a timeout value for the transaction scope beforehand, the deadlock can be broken.</p></li></ul></li></ul></div></div><div class="header_footer"><div class="back_next"><a href="j2681-00-04-04-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-04-05-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>