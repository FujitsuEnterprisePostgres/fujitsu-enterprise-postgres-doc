<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>9.5.1 DBMS_SQL</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-00-09-00-00.html">Chapter&nbsp;9 Compatibility with Oracle Databases</a> &gt; <a href="j2681-00-09-05-00.html">9.5 Package Reference</a> &gt; 9.5.1 DBMS_SQL</div><div class="back_next"><a href="j2681-00-09-05-00.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-10-00-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_070503">9.5.1 DBMS_SQL<a name="N50G"></a></h3><div class="body"><div class="textblock"><dl><dt class="em">Overview</dt><dd><p>Dynamic SQL can be executed from PL/pgSQL.</p></dd></dl><dl><dt class="em">Features</dt><dd><table><col><col><tr><th bgcolor="#F2F2F2" valign="middle"><p><span class="em">Feature</span></p></th><th bgcolor="#F2F2F2" valign="middle"><p><span class="em">Description</span></p></th></tr><tr><td align="left" valign="middle"><p>BIND_VARIABLE</p></td><td align="left" valign="middle"><p>Sets values in the host variable within the SQL statement.</p></td></tr><tr><td align="left" valign="middle"><p>CLOSE_CURSOR</p></td><td align="left" valign="middle"><p>Closes the cursor.</p></td></tr><tr><td align="left" valign="middle"><p>COLUMN_VALUE</p></td><td align="left" valign="middle"><p>Retrieves the value of the column in the select list extracted with FETCH_ROWS.</p></td></tr><tr><td align="left" valign="middle"><p>DEFINE_COLUMN</p></td><td align="left" valign="middle"><p>Defines the column from which values are extracted and the storage destination.</p></td></tr><tr><td align="left" valign="middle"><p>EXECUTE</p></td><td align="left" valign="middle"><p>Executes SQL statements.</p></td></tr><tr><td align="left" valign="middle"><p>FETCH_ROWS</p></td><td align="left" valign="middle"><p>Positions the specified cursor at the next row and extracts values from the row.</p></td></tr><tr><td align="left" valign="middle"><p>OPEN_CURSOR</p></td><td align="left" valign="middle"><p>Opens a new cursor.</p></td></tr><tr><td align="left" valign="middle"><p>PARSE</p></td><td align="left" valign="middle"><p>Parses SQL statements.</p></td></tr></table></dd></dl><div class="note"><p class="title">Note</p><div class="notebody"><ul><li><p>In DBMS_SQL, the data types supported in dynamic SQL are limited, and therefore the user must consider this. The supported data types are:</p><ul><li><p>INTEGER</p></li><li><p>DECIMAL</p></li><li><p>NUMERIC</p></li><li><p>REAL</p></li><li><p>DOUBLE PRECISION</p></li><li><p>CHAR<span class="inline-note">*1</span></p></li><li><p>VARCHAR<span class="inline-note">*1</span></p></li><li><p>NCHAR<span class="inline-note">*1</span></p></li><li><p>NCHAR VARYING<span class="inline-note">*1</span></p></li><li><p>TEXT</p></li><li><p>DATE</p></li><li><p>TIMESTAMP WITHOUT TIME ZONE</p></li><li><p>TIMESTAMP WITH TIME ZONE</p></li><li><p>INTERVAL<span class="inline-note">*2</span></p></li><li><p>SMALLINT</p></li><li><p>BIGINT</p><p>*1:<br>The host variables with CHAR, VARCHAR, NCHAR, and NCHAR VARYING data types are treated as TEXT, to match the string function arguments and return values. Refer to "String Functions and Operators" in "Functions and Operators" in "The SQL Language" in the PostgreSQL Documentation for information on string functions.<br>When specifying the arguments of the features compatible with Oracle databases NVL and/or DECODE, use CAST to convert the data types of the host variables to ensure that data types between arguments are the same.</p><p>*2:<br>When using COLUMN_VALUE to obtain an INTERVAL type value specified in the select list, use an INTERVAL type variable with a wide range such as when no interval qualifier is specified, or with a range that matches that of the variable in the select list. If an interval qualifier variable with a narrow range is specified, then the value within the interval qualifier range will be obtained, but an error that the values outside the range have been truncated will not occur.</p><div class="ex"><p class="title">Example</p><div class="exbody"><p>This example illustrates where a value expression that returns an INTERVAL value is set in the select list and the result is received with COLUMN_VALUE. Note that the SQL statement operation result returns a value within the INTERVAL DAY TO SECOND range.</p><p><span class="em">[</span><span class="em">B</span><span class="em">ad example]</span></p><p>Values of MINUTE, and those after MINUTE, are truncated, because the variable(v_interval) is INTERVAL DAY TO HOUR.</p><pre class="border">    <span class="em">v_interval     INTERVAL DAY TO HOUR;</span>...    PERFORM DBMS_SQL.PARSE(cursor, 'SELECT CURRENT_TIMESTAMP - ''2010-01-01'' FROM DUAL', 1);...    SELECT value INTO v_interval FROM DBMS_SQL.COLUMN_VALUE(cursor, 1, v_interval);    result:1324 days 09:00:00</pre><p><span class="em">[</span><span class="em">G</span><span class="em">ood example]</span></p><p>By ensuring that the variable(v_interval) is INTERVAL, the values are received correctly.</p><pre class="border">    <span class="em">v_interval     INTERVAL;</span>...    PERFORM DBMS_SQL.PARSE(cursor, 'SELECT CURRENT_TIMESTAMP - ''2010-01-01'' FROM DUAL', 1);...    SELECT value INTO v_interval FROM DBMS_SQL.COLUMN_VALUE(cursor, 1, v_interval);    result:1324 days 09:04:37.530623</pre></div></div></li></ul></li></ul></div></div><dl><dt class="em">Syntax</dt><dd><pre>{ BIND_VARIABLE(<span class="i">cursor</span>, <span class="i">varName</span>, <span class="i">val</span> [, <span class="i">len</span> ])| CLOSE_CURSOR(<span class="i">cursor</span>)| COLUMN_VALUE(<span class="i">cursor</span>, <span class="i">colPos</span>, <span class="i">varName</span>)| DEFINE_COLUMN(<span class="i">cursor</span>, <span class="i">colPos</span>, <span class="i">varName</span> [, <span class="i">len</span> ])| EXECUTE(<span class="i">cursor</span>)| FETCH_ROWS(<span class="i">cursor</span>)| OPEN_CURSOR([<span class="i">parm1 </span>])| PARSE(<span class="i">cursor</span>, <span class="i">sqlStmt</span>, <span class="i">parm1</span> [, <span class="i">parm2</span>, <span class="i">parm3</span>, <span class="i">parm4</span> ]) }</pre></dd></dl><p></p></div></div><h4 id="IDapl07N1">9.5.1.1 Description</h4><div class="body"><div class="textblock"><p>This section explains each feature of DBMS_SQL.</p><br><dl><dt class="em">BIND_VARIABLE<a name="N51G"></a></dt><dd><ul><li><p>BIND_VARIABLE sets values in the host variable within the SQL statement.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>Specify the name of the host variable within the SQL statement using a string for the host variable name.</p></li><li><p>Specify the value set in the host variable. The data type of the host variable is the same as that of the value expression - it is implicitly converted in accordance with its position within the SQL statement. Refer to "<a href="j2681-a-03-00.html">A.3 Implicit Data Type Conversions</a>" for information on implicit conversions.</p></li><li><p>If the value is a character type, the string length is the number of characters. If the string length is not specified, the size is the total length of the string.</p></li><li><p>It is necessary to place a colon at the beginning of the host variable in SQL statements to identify the host variable. The colon does not have to be added to the host variable names specified at BIND_VARIABLE. The following shows examples of host variable names specified with SQL statements and host variable names specified with BIND_VARIABLE:<br></p><pre class="border">PERFORM DBMS_SQL.PARSE(cursor, 'SELECT emp_name FROM emp WHERE sal &gt; :x', 1);</pre><p>In this example, BIND_VARIABLE will be as follows:</p><pre class="border">PERFORM DBMS_SQL.BIND_VARIABLE(cursor, ':x', 3500);</pre><p>Or,</p><pre class="border">PERFORM DBMS_SQL.BIND_VARIABLE(cursor, 'x', 3500);</pre></li><li><p>The length of the host variable name can be up to 30 bytes (excluding colons).</p></li><li><p>If the data type of the set value is string, specify the effective size of the column value as the fourth argument.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><p>If the data type of the value to be set is not a string:</p><pre class="border">PERFORM DBMS_SQL.BIND_VARIABLE(cursor, ':NO', 1);</pre><p>If the data type of the value to be set is a string:</p><pre class="border">PERFORM DBMS_SQL.BIND_VARIABLE(cursor, ':NAME', h_memid, 5);</pre></div></div><br></dd></dl><dl><dt class="em">CLOSE_CURSOR<a name="N52G"></a></dt><dd><ul><li><p>CLOSE_CURSOR closes the cursor.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>The value returned is a NULL value.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">cursor := DBMS_SQL.CLOSE_CURSOR(cursor);</pre></div></div><br></dd></dl><dl><dt class="em">COLUMN_VALUE<a name="N53G"></a></dt><dd><ul><li><p>COLUMN_VALUE retrieves the value of the column in the select list extracted with FETCH_ROWS.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>Specify the position of the column of the select list in the SELECT statement. The position of the first column is 1.</p></li><li><p>Specify the destination variable name.</p></li><li><p>Use a SELECT statement to obtain the values of the value, column_error, and actual_length columns.</p></li><li><p>The value column returns the value of the column specified at the column position. The data type of the variable name must match that of the column. If the data type of the column in the SELECT statement specified in PARSE is not compatible with DBMS_SQL, use CAST to convert to a compatible data type.</p></li><li><p>The data type of the column_error column is NUMERIC. If the column value could not be set correctly in the value column, a value other than 0 will be returned:<br>22001: The extracted string has been truncated<br>22002: The extracted value contains a NULL value</p></li><li><p>The data type of the actual_length column is INTEGER. If the extracted value is a character type, the number of characters will be returned (if the value was truncated, the number of characters prior to the truncation will be returned), otherwise, the number of bytes will be returned.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><p>When retrieving the value of the column, the error code, and the actual length of the column value:</p><pre class="border">SELECT value, column_error, actual_length INTO v_memid, v_col_err, v_act_len FROM DBMS_SQL.COLUMN_VALUE(cursor, 1, v_memid);</pre><p>When retrieving just the value of the column:</p><pre class="border">SELECT value INTO v_memid FROM DBMS_SQL.COLUMN_VALUE(cursor, 1, v_memid);</pre></div></div><br></dd></dl><dl><dt class="em">DEFINE_COLUMN<a name="N54G"></a></dt><dd><ul><li><p>DEFINE_COLUMN defines the column from which values are extracted and the storage destination.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>Specify the position of the column in the select list in the SELECT statement. The position of the first column is 1.</p></li><li><p>Specify the destination variable name. The data type should be match with the data type of the column from which the value is to be extracted. If the data type of the column in the SELECT statement specified in PARSE is not compatible with DBMS_SQL, use CAST to convert to a compatible data type.</p></li><li><p>Specify the maximum number of characters of character type column values.</p></li><li><p>If the data type of the column value is string, specify the effective size of the column value as the fourth argument.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><p>When the data type of the column value is not a string:</p><pre class="border">PERFORM DBMS_SQL.DEFINE_COLUMN(cursor, 1, v_memid);</pre><p>When the data type of the column value is a string:</p><pre class="border">PERFORM DBMS_SQL.DEFINE_COLUMN(cursor, 1, v_memid, 10);</pre></div></div><br></dd></dl><dl><dt class="em">EXECUTE<a name="N55G"></a></dt><dd><ul><li><p>EXECUTE executes SQL statements.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>The return value is an INTEGER type, is valid only with INSERT statement, UPDATE statement, and DELETE statement, and is the number of rows processed. Anything else is invalid.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">ret := DBMS_SQL.EXECUTE(cursor);</pre></div></div><br></dd></dl><dl><dt class="em">FETCH_ROWS<a name="N56G"></a></dt><dd><ul><li><p>FETCH_ROWS positions at the next row and extracts values from the row.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>The return value is an INTEGER type and is the number of rows extracted. 0 is returned if all are extracted.</p></li><li><p>The extracted information is retrieved with COLUMN_VALUE.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">LOOP    IF DBMS_SQL.FETCH_ROWS(cursor) = 0 THEN        EXIT;    END IF;...END LOOP;</pre></div></div><br></dd></dl><dl><dt class="em">OPEN_CURSOR<a name="N57G"></a></dt><dd><ul><li><p>OPEN_CURSOR opens a new cursor.</p></li><li><p>The parameter is used for compatibility with Oracle databases only, and is ignored by FUJITSU Enterprise Postgres. An INTEGER type can be specified, but it will be ignored. If migrating from an Oracle database, specify 1.</p></li><li><p>Close unnecessary cursors by executing CLOSE_CURSOR.</p></li><li><p>The return value is an INTEGER type and is the cursor number.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">cursor := DBMS_SQL.OPEN_CURSOR();</pre></div></div><br></dd></dl><dl><dt class="em">PARSE<a name="N58G"></a></dt><dd><ul><li><p>PARSE analyzes dynamic SQL statements.</p></li><li><p>Specify the cursor number to be processed.</p></li><li><p>Specify the SQL statement to be parsed.</p></li><li><p>Parameters 1, 2, 3, and 4 are used for compatibility with Oracle databases only, and are ignored by FUJITSU Enterprise Postgres. If you are specifying values anyway, specify the following:<br>- Parameter 1 is an INTEGER type. Specify 1.<br>- Parameters 2 and 3 are TEXT types. Specify NULL.<br>- Parameter 4 is a BOOLEAN type. Specify TRUE.<br>If migrating from an Oracle database, the specified values for parameters 2, 3, and 4 do not need to be changed.</p></li><li><p>Add a colon to the beginning of host variables in SQL statements.</p></li><li><p>The DDL statement is executed when PARSE is issued. EXECUTE is not required for the DDL statement.</p></li><li><p>If PARSE is called again for opened cursors, the content in the data regions within the cursors is reset, and the SQL statement is parsed anew.</p></li></ul><div class="ex"><p class="title">Example</p><div class="exbody"><pre class="border">PERFORM DBMS_SQL.PARSE(cursor, 'SELECT memid, memnm FROM member WHERE memid = :NO', 1);</pre></div></div><br></dd></dl></div></div><h4 id="IDapl07N2">9.5.1.2 Example</h4><div class="body"><div class="textblock"><p>This section explains the flow of DBMS_SQL and provides an example.</p></div><p class="subhead_1" id="IDapl07N3"><span class="em">Flow of </span><span class="em">DBMS_SQL</span></p><div class="textblock"><p><img src="apl07img/e-070504-dbms-sql-flow.gif" alt="" width="357" height="693"></p></div><p class="subhead_1" id="IDapl07N4"><span class="em">Example</span></p><div class="textblock"><pre class="border">CREATE FUNCTION smp_00()RETURNS INTEGERAS $$DECLARE    str_sql     VARCHAR(255);    cursor      INTEGER;    h_smpid     INTEGER;    v_smpid     INTEGER;    v_smpnm     VARCHAR(20);    v_smpage    INTEGER;    errcd       INTEGER;    length      INTEGER;    ret         INTEGER;BEGIN    str_sql     := 'SELECT smpid, smpnm, smpage FROM smp_tbl WHERE smpid &lt; :H_SMPID ORDER BY smpid';    h_smpid     := 3;    v_smpid     := 0;    v_smpnm     := '';    v_smpage    := 0;    cursor := DBMS_SQL.OPEN_CURSOR();    PERFORM DBMS_SQL.PARSE(cursor, str_sql, 1);    PERFORM DBMS_SQL.BIND_VARIABLE(cursor, ':H_SMPID', h_smpid);    PERFORM DBMS_SQL.DEFINE_COLUMN(cursor, 1, v_smpid);    PERFORM DBMS_SQL.DEFINE_COLUMN(cursor, 2, v_smpnm, 10);    PERFORM DBMS_SQL.DEFINE_COLUMN(cursor, 3, v_smpage);    ret := DBMS_SQL.EXECUTE(cursor);    loop        if DBMS_SQL.FETCH_ROWS(cursor) = 0 then            EXIT;        end if;        SELECT value,column_error,actual_length INTO v_smpid,errcd,length FROM DBMS_SQL.COLUMN_VALUE(cursor, 1, v_smpid);        RAISE NOTICE '--------------------------------------------------------';        RAISE NOTICE '--------------------------------------------------------';        RAISE NOTICE 'smpid       = %', v_smpid;        RAISE NOTICE 'errcd       = %', errcd;        RAISE NOTICE 'length      = %', length;        SELECT value,column_error,actual_length INTO v_smpnm,errcd,length FROM DBMS_SQL.COLUMN_VALUE(cursor, 2, v_smpnm);        RAISE NOTICE '--------------------------------------------------------';        RAISE NOTICE 'smpnm       = %', v_smpnm;        RAISE NOTICE 'errcd       = %', errcd;        RAISE NOTICE 'length      = %', length;        select value,column_error,actual_length INTO v_smpage,errcd,length FROM DBMS_SQL.COLUMN_VALUE(cursor, 3, v_smpage);        RAISE NOTICE '--------------------------------------------------------';        RAISE NOTICE 'smpage      = %', v_smpage;        RAISE NOTICE 'errcd       = %', errcd;        RAISE NOTICE 'length      = %', length;        RAISE NOTICE '';    end loop;    cursor := DBMS_SQL.CLOSE_CURSOR(cursor);    RETURN 0;END;$$ LANGUAGE plpgsql;</pre></div></div><div class="header_footer"><div class="back_next"><a href="j2681-00-09-05-00.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-00-10-00-00.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>