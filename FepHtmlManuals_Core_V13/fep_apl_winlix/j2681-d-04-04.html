<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>D.4.4 Type Mapping</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-d-00-00.html">Appendix&nbsp;D ECOBPG - Embedded SQL in COBOL</a> &gt; <a href="j2681-d-04-00.html">D.4 Using Host Variables</a> &gt; D.4.4 Type Mapping</div><div class="back_next"><a href="j2681-d-04-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-05.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_0e0404">D.4.4 Type Mapping</h3><div class="body"><div class="textblock"><p>When ECOBPG applications exchange values between the PostgreSQL server and the COBOL application, such as when retrieving query results from the server or executing SQL statements with input parameters, the values need to be converted between PostgreSQL data types and host language variable types (specifically COBOL language data types). One of the main points of ECOBPG is that it takes care of this automatically in most cases.</p><p>In this respect, there are two kinds of data types: Some simple PostgreSQL data types, such as integer and text, can be read and written by the application directly. Other PostgreSQL data types, such as timestamp and date can only be accessed through character strings. special library functions does not exist in ecobpg. (pgtypes, exists in ECPG, for COBOL is not implemented yet)</p><p>"<a href="j2681-d-04-04.html#mID_0e0404_table1">Table&nbsp;D.1 Mapping Between PostgreSQL Data Types and COBOL Variable Types</a>" shows which PostgreSQL data types correspond to which COBOL data types. When you wish to send or receive a value of a given PostgreSQL data type, you should declare a COBOL variable of the corresponding COBOL data type in the declare section.</p><table><caption id="mID_0e0404_table1">Table&nbsp;D.1 Mapping Between PostgreSQL Data Types and COBOL Variable Types</caption><col><col><tr><th valign="middle"><p><span class="em">PostgreSQL data type</span></p></th><th valign="middle"><p><span class="em">COBOL Host variable type</span></p></th></tr><tr><td align="left" valign="middle"><p>smallint</p></td><td align="left" valign="middle"><p>PIC S9([1-4]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>integer</p></td><td align="left" valign="middle"><p>PIC S9([5-9]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>bigint</p></td><td align="left" valign="middle"><p>PIC S9([10-18]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>decimal</p></td><td align="left" valign="middle"><p>PIC S9(m)V9(n) PACKED-DECIMAL<br>PIC 9(m)V9(n) DISPLAY <span class="inline-note">*1</span><br>PIC S9(m)V9(n) DISPLAY<br>PIC S9(m)V9(n) DISPLAY SIGN TRAILING [SEPARATE]<br>PIC S9(m)V9(n) DISPLAY SIGN LEADING [SEPARATE]</p></td></tr><tr><td align="left" valign="middle"><p>numeric</p></td><td align="left" valign="middle"><p>(same with decimal)</p></td></tr><tr><td align="left" valign="middle"><p>real</p></td><td align="left" valign="middle"><p>COMP-1</p></td></tr><tr><td align="left" valign="middle"><p>double precision</p></td><td align="left" valign="middle"><p>COMP-2</p></td></tr><tr><td align="left" valign="middle"><p>small serial</p></td><td align="left" valign="middle"><p>PIC S9([1-4]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>serial</p></td><td align="left" valign="middle"><p>PIC S9([1-9]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>bigserial</p></td><td align="left" valign="middle"><p>PIC S9([10-18]) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>oid</p></td><td align="left" valign="middle"><p>PIC 9(9) {BINARY|COMP|COMP-5}</p></td></tr><tr><td align="left" valign="middle"><p>character(<span class="i">n</span>), varchar(<span class="i">n</span>), text</p></td><td align="left" valign="middle"><p>PIC X(<span class="i">n</span>), PIC X(<span class="i">n</span>) VARYING</p></td></tr><tr><td align="left" valign="middle"><p>name</p></td><td align="left" valign="middle"><p>PIC X(NAMEDATALEN)</p></td></tr><tr><td align="left" valign="middle"><p>boolean</p></td><td align="left" valign="middle"><p>BOOL<span class="inline-note">*2</span></p></td></tr><tr><td align="left" valign="top"><p>bytea</p></td><td align="left" valign="top"><p>BYTEA(n)</p></td></tr><tr><td align="left" valign="middle"><p>other types(e.g. timestamp)</p></td><td align="left" valign="middle"><p>PIC X(<span class="i">n</span>), PIC X(<span class="i">n</span>) VARYING</p></td></tr><tr><td colspan="2" align="left" valign="middle"><p>*1: If no USAGE is specified, host variable is regarded as DISPLAY.<br>*2: Type definition is added automatically on pre-compiling.<br>Body of BOOL is PIC X(1). '1' for true and '0' for false. <br><br>You can use some pattern of digits for integer(see table), but if database sends big number with<br>more digits than specified, behavior is undefined. <br><br>VALUE clause can't be used with VARYING. (Can be used with other types)<br>REDEFINE clause can be used, but it won't be validated on pre-compilation (The COBOL compiler will do this).</p></td></tr></table><p></p></div><p class="subhead_1" id="mID_0e0404_handling_characters_strings"><span class="em">Handling Character Strings</span></p><div class="textblock"><p>To handle SQL character string data types, such as varchar and text, there is a possible way to declare the host variables.</p><p>The way is using the PIC X(<span class="i">n</span>) VARYING type (we call it VARCHAR type from now on), which is a special type provided by ECOBPG. The definition on type VARCHAR is converted into a group item consists of named variables. A declaration like:</p><pre class="border">01 VAR PIC X(180) VARYING.</pre><p>is converted into:</p><pre class="border">01 VAR.49 LEN PIC S9(4) COMP-5.49 ARR PIC X(180).</pre><br><p>if --varchar-with-named-member option is used, it is converted into:</p><pre class="border">01 VAR.49 VAR-LEN PIC S9(4) COMP-5.49 VAR-ARR PIC X(180).</pre><p>You can use level 1 to 48 for VARCHAR. Don't use level 49 variable right after VARCHAR variable. To use a VARCHAR host variable as an input for SQL statement, LEN must be set the length of the string included in ARR.</p><p>To use a VARCHAR host variable as an output of SQL statement, the variable must be declared in a sufficient length. If the length is insufficient, it can cause a buffer overrun.</p><p>PIC X(<span class="i">n</span>) and VARCHAR host variables can also hold values of other SQL types, which will be stored in their string forms.</p></div><p class="subhead_1" id="mID_0e0404_special_data_types"><span class="em">Accessing Special Data Types</span></p><div class="textblock"><p>ECOBPG doesn't have special support for date, timestamp, and interval types. <br>(ECPG has pgtypes, but ECOBPG doesn't.)<br>You can use PIC X(<span class="i">n</span>) or VARCHAR for DB I/O with these types. See "Data Types" section in PostgreSQL's document.</p><dl><dt class="em">bytea</dt><dd><p>Handling of bytea types is similar to VARCHAR. The definition of an array of type bytea is converted into a group item consists of named variables.</p><p>A declaration like:</p><pre class="border">01 var bytea(100).</pre><p>is converted into:</p><pre class="border">01 var .49 LEN PIC S9(9) COMP-5 .49 ARR PIC X(100) .</pre><p>if bytea-with-named-member option is used, it is converted into:</p><pre class="border">01 var .49 var-LEN PIC S9(9) COMP-5 .49 var-ARR PIC X(100) .</pre><p>The data item ARR holds binary format data. Unlike VARCHAR, it is not affected by the locale or character encoding when processing data.</p><p>Other usage and prohibitions are the same as VARCHAR.</p><div class="note"><p class="title">Note</p><div class="notebody"><p>The bytea variable can only be used if byta_output is set to hex.</p></div></div></dd></dl></div><p class="subhead_1" id="mID_0e0404_nonprimitive_types"><span class="em">Host Variables with Nonprimitive Types</span></p><div class="textblock"><p>As a host variable you can also use arrays, typedefs, and group items.</p><dl><dt class="em" id="mID_0e0404_arrays">Arrays</dt><dd><p>To create and use array variables, OCCURENCE syntax is provided by COBOL.</p><p>The typical use case is to retrieve multiple rows from a query result without using a cursor. Without an array, to process a query result consisting of multiple rows, it is required to use a cursor and the FETCH command. But with array host variables, multiple rows can be received at once. The length of the array has to be defined to be able to accommodate all rows, otherwise a buffer overrun will likely occur.</p><p>Following example scans the pg_database system table and shows all OIDs and names of the available databases:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 GROUP-ITEM.    05 DBID PIC S9(9) COMP OCCURS 8.    05 DBNAME PIC X(16) OCCURS 8.01 I PIC S9(9) COMP.EXEC SQL END DECLARE SECTION END-EXEC.    EXEC SQL CONNECT TO testdb END-EXEC.*   Retrieve multiple rows into arrays at once.    EXEC SQL SELECT oid,datname INTO :DBID, :DBNAME FROM pg_database END-EXEC.    PERFORM VARYING I FROM 1 BY 1 UNTIL I &gt; 8        DISPLAY "oid=" DBID(I) ", dbname=" DBNAME(I)    END-PERFORM.    EXEC SQL COMMIT END-EXEC.    EXEC SQL DISCONNECT ALL END-EXEC.</pre><p>You can use member of array as simple host variable by specifying subscript of array. For specifying subscript, use C-style "[1]", not COBOL-style "(1)". But subscript starts with 1, according to COBOL syntax.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 GROUP-ITEM.    05 DBID PIC S9(9) COMP OCCURS 8.EXEC SQL END DECLARE SECTION END-EXEC.    EXEC SQL CONNECT TO testdb END-EXEC.    EXEC SQL SELECT oid INTO :DBID[1] FROM pg_database WHERE oid=1 END-EXEC.        DISPLAY "oid=" DBID(1)    EXEC SQL COMMIT END-EXEC.    EXEC SQL DISCONNECT ALL END-EXEC.</pre><br></dd></dl><dl><dt class="em" id="mID_0e0404_group_item">Group Item</dt><dd><p>A group item whose subordinate item names match the column names of a query result, can be used to retrieve multiple columns at once. The group item enables handling multiple column values in a single host variable.</p><p>The following example retrieves OIDs, names, and sizes of the available databases from the pg_database system table by using the pg_database_size() function. In this example, a group item variable dbinfo_t with members whose names match each column in the SELECT result is used to retrieve one result row without putting multiple host variables in the FETCH statement.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.    01 DBINFO-T TYPEDEF.       02 OID PIC S9(9) COMP.       02 DATNAME PIC X(65).       02 DBSIZE PIC S9(18) COMP.    01 DBVAL TYPE DBINFO-T.EXEC SQL END DECLARE SECTION END-EXEC.    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database END-EXEC.    EXEC SQL OPEN cur1 END-EXEC.*   when end of result set reached, break out of loop     EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.    PERFORM NO LIMIT*        Fetch multiple columns into one structure.        EXEC SQL FETCH FROM cur1 INTO :DBVAL END-EXEC*        Print members of the structure.        DISPLAY "oid=" OID ", datname=" DATNAME ", size=" DBSIZE    END-PERFORM.    END-FETCH.    EXEC SQL CLOSE cur1 END-EXEC.</pre></dd></dl><p>group item host variables "absorb" as many columns as the group item as subordinate items. Additional columns can be assigned to other host variables. For example, the above program could also be restructured like this, with the size variable outside the group item:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.    01 DBINFO-T TYPEDEF.       02 OID PIC S9(9) COMP.       02 DATNAME PIC X(65).    01 DBVAL TYPE DBINFO-T.    01 DBSIZE PIC S9(18) COMP.EXEC SQL END DECLARE SECTION END-EXEC.    EXEC SQL DECLARE cur1 CURSOR FOR SELECT oid, datname, pg_database_size(oid) AS size FROM pg_database END-EXEC.    EXEC SQL OPEN cur1 END-EXEC.*   when end of result set reached, break out of loop    EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.    PERFORM NO LIMIT*       Fetch multiple columns into one structure.        EXEC SQL FETCH FROM cur1 INTO :DBVAL, :DBSIZE END-EXEC*       Print members of the structure.        DISPLAY "oid=" OID ", datname=" DATNAME ", size=" DBSIZE    END-PERFORM    FETCH-END.    EXEC SQL CLOSE cur1 END-EXEC.</pre><br><p>You can use only non-nested group items for host variable of SQL statement. Declaration of nested group items are OK, but you must specify non-nested part of group items for SQL. (VARCHAR, is translated to group item on pre-compilation, is not considered as offense of this rule.) When using inner item of group item in SQL, use C-struct like period separated syntax(not COBOL's A OF B). Here is example.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 NESTED-GROUP.  02 CHILD1.    03 A PIC X(10).    03 B PIC S9(9) COMP.  02 CHILD2.    03 A PIC X(10).    03 B PIC S9(9) COMP.EXEC SQL END DECLARE SECTION END-EXEC.* This SQL is valid. CHILD1 has no nested group items.EXEC SQL SELECT * INTO :NESTED-GROUP.CHILD1 FROM TABLE1 END-EXEC.</pre><br><p>For specifying basic item of group items, full specification is not needed if the specification is enough for identifying the item. This is from COBOL syntax. For more detail, see resources of COBOL syntax.</p><br><dl><dt class="em" id="mID_0e0404_typedef">TYPEDEF</dt><dd><p>Use the typedef keyword to map new types to already existing types.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.    01 MYCHARTYPE TYPEDEF PIC X(40).    01 SERIAL-T TYPEDEF PIC S9(9) COMP.EXEC SQL END DECLARE SECTION END-EXEC.</pre><p>Note that you could also use:</p><pre class="border">EXEC SQL TYPE SERIAL-T IS PIC S9(9) COMP-5. END-EXEC.</pre><br><p>This declaration does not need to be part of a declare section.</p></dd></dl></div></div><div class="header_footer"><div class="back_next"><a href="j2681-d-04-03.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-05.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>