<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html lang="en"><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><META CONTENT="4.3" NAME="GeneratorVersion"><title>D.4.5 Handling Nonprimitive SQL Data Types</title><link rel="stylesheet" href="manualmain.css" type="TEXT/CSS"><script language="JavaScript" src="topbutton.js"></script></head><body onload="init()"><div class="topButton" id="topButton0"><a class="topButton" href="#top"><img src="image/top.gif" width="62" height="20" border="0" alt="Top" title="Top"></a></div><div class="top_header"><div class="top_header_title"><a title="Title Page" class="top_link" target="_top" HREF="index.html">Enterprise Postgres 13&nbsp;Application Development Guide</a></div><div class="top_header_graphic"><span class="top_logo"><img src="image/logo-white-fj.gif" width="148" height="32" alt=""></span><span class="top_keygraphic"><img src="image/cover-header-graphic.gif" width="148" height="32" alt="FUJITSU Software"></span></div></div><div class="header_footer"><div class="breadcrumbslist"><a href="j2681-d-00-00.html">Appendix&nbsp;D ECOBPG - Embedded SQL in COBOL</a> &gt; <a href="j2681-d-04-00.html">D.4 Using Host Variables</a> &gt; D.4.5 Handling Nonprimitive SQL Data Types</div><div class="back_next"><a href="j2681-d-04-04.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-06.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div></div><h3 id="mID_0e0405">D.4.5 Handling Nonprimitive SQL Data Types</h3><div class="body"><div class="textblock"><p>This section contains information on how to handle nonscalar and user-defined SQL-level data types in ECOBPG applications. Note that this is distinct from the handling of host variables of nonprimitive types, described in the previous section.</p><p></p></div><p class="subhead_1" id="mID_0e0405_arrays"><span class="em">Arrays</span></p><div class="textblock"><p>SQL-level arrays are not directly supported in ECOBPG. It is not possible to simply map an SQL array into a COBOL array host variable. This will result in undefined behavior. Some workarounds exist, however.</p><p>If a query accesses elements of an array separately, then this avoids the use of arrays in ECOBPG. Then, a host variable with a type that can be mapped to the element type should be used. For example, if a column type is array of integer, a host variable of type PIC S9(9) COMP can be used. Also if the element type is varchar or text, a host variable of type VARCHAR can be used.</p><p>Here is an example. Assume the following table:</p><pre class="border">CREATE TABLE t3 (    ii integer[]);testdb=&gt; SELECT * FROM t3;     ii------------- {1,2,3,4,5}(1 row)</pre><br><p>The following example program retrieves the 4th element of the array and stores it into a host variable of type PIC S9(9) COMP-5:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 II PIC S9(9) COMP.EXEC SQL END DECLARE SECTION END-EXEC.EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[4] FROM t3 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT    EXEC SQL FETCH FROM cur1 INTO :II  END-EXEC    DISPLAY "ii=" IIEND-PERFORM.END-FETCH.EXEC SQL CLOSE cur1 END-EXEC.</pre><br><p>To map multiple array elements to the multiple elements in an array type host variables each element of array column and each element of the host variable array have to be managed separately, for example:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 GROUP-ITEM.    05 II_A PIC S9(9) COMP OCCURS 8.EXEC SQL END DECLARE SECTION END-EXEC.EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii[1], ii[2], ii[3], ii[4] FROM t3 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT    EXEC SQL FETCH FROM cur1 INTO :II_A[1], :II_A[2], :II_A[3], :II_A[4] END-EXEC    ...END-PERFORM.</pre><p>Note again that.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 GROUP-ITEM.    05 II_A PIC S9(9) COMP OCCURS 8.EXEC SQL END DECLARE SECTION END-EXEC.EXEC SQL DECLARE cur1 CURSOR FOR SELECT ii FROM t3 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT*   WRONG    EXEC SQL FETCH FROM cur1 INTO :II_A END-EXEC    ...END-PERFORM.</pre><p>would not work correctly in this case, because you cannot map an array type column to an array host variable directly.</p><p>Another workaround is to store arrays in their external string representation in host variables of type VARCHAR. For more details about this representation.</p><div class="ref"><p class="title">See</p><div class="refbody"><p>Refer to "Arrays" in "Tutorial" in the PostgreSQL Documentation for information more details about this representation.</p></div></div><p>Note that this means that the array cannot be accessed naturally as an array in the host program (without further processing that parses the text representation).</p></div><p class="subhead_1" id="mID_0e0405_composite_types"><span class="em">Composite Types</span></p><div class="textblock"><p>Composite types are not directly supported in ECOBPG, but an easy workaround is possible. The available workarounds are similar to the ones described for arrays above: Either access each attribute separately or use the external string representation.</p><p>For the following examples, assume the following type and table:</p><pre class="border">CREATE TYPE comp_t AS (intval integer, textval varchar(32));CREATE TABLE t4 (compval comp_t);INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );</pre><p>The most obvious solution is to access each attribute separately. The following program retrieves data from the example table by selecting each attribute of the type comp_t separately:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 INTVAL PIC S9(9) COMP.01 TEXTVAL PIC X(33) VARYING.EXEC SQL END DECLARE SECTION END-EXEC.* Put each element of the composite type column in the SELECT list.EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT*   Fetch each element of the composite type column into host variables.    EXEC SQL FETCH FROM cur1 INTO :INTVAL, :TEXTVAL END-EXEC    DISPLAY "intval=" INTVAL ", textval=" ARR OF TEXTVALEND-PERFORM.END-FETCH.EXEC SQL CLOSE cur1 END-EXEC.</pre><p>To enhance this example, the host variables to store values in the FETCH command can be gathered into one group item. For more details about the host variable in the group item form, see "<a href="j2681-d-04-04.html#mID_0e0404_group_item">Group Item</a>". To switch to the group item, the example can be modified as below. The two host variables, intval and textval, become subordinate items of the comp_t group item, and the group item is specified on the FETCH command.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 COMP-T TYPEDEF.    02 INTVAL PIC S9(9) COMP.    02 TEXTVAL PIC X(33) VARYING.01 COMPVAL TYPE COMP-T.EXEC SQL END DECLARE SECTION END-EXEC.* Put each element of the composite type column in the SELECT list.EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).intval, (compval).textval FROM t4 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT*   Put all values in the SELECT list into one structure.    EXEC SQL FETCH FROM cur1 INTO :COMPVAL END-EXEC    DISPLAY "intval=" INTVAL ", textval=" ARR OF TEXTVALEND-PERFORM.END-FETCH.EXEC SQL CLOSE cur1 END-EXEC.</pre><p>Although a group item is used in the FETCH command, the attribute names in the SELECT clause are specified one by one. This can be enhanced by using a * to ask for all attributes of the composite type value.</p><pre class="border">...EXEC SQL DECLARE cur1 CURSOR FOR SELECT (compval).* FROM t4 END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT*   Put all values in the SELECT list into one structure.    EXEC SQL FETCH FROM cur1 INTO :COMPVAL END-EXEC    DISPLAY "intval=" INTVAL ", textval=" ARR OF TEXTVALEND-PERFORM.</pre><p>This way, composite types can be mapped into structures almost seamlessly, even though ECOBPG does not understand the composite type itself.</p><p>Finally, it is also possible to store composite type values in their external string representation in host variables of type VARCHAR. But that way, it is not easily possible to access the fields of the value from the host program.</p></div><p class="subhead_1" id="mID_0e0405_user_defined_base_types"><span class="em">User-defined Base Types</span></p><div class="textblock"><p>New user-defined base types are not directly supported by ECOBPG. You can use the external string representation and host variables of type VARCHAR, and this solution is indeed appropriate and sufficient for many types.</p><p>Here is an example using the data type complex.</p><div class="ref"><p class="title">See</p><div class="refbody"><p>Refer to "User-defined Types" in "Server Programming" in the PostgreSQL Documentation for information on the data type complex.</p></div></div><p>The external string representation of that type is (%lf,%lf), which is defined in the functions complex_in() and complex_out() functions. The following example inserts the complex type values (1,1) and (3,3) into the columns a and b, and select them from the table after that.</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.    01 A PIC X(64) VARYING.    01 B PIC X(64) VARYING.EXEC SQL END DECLARE SECTION END-EXEC.EXEC SQL INSERT INTO test_complex VALUES ('(1,1)', '(3,3)') END-EXEC.EXEC SQL DECLARE cur1 CURSOR FOR SELECT a, b FROM test_complex END-EXEC.EXEC SQL OPEN cur1 END-EXEC.EXEC SQL WHENEVER NOT FOUND GOTO END-FETCH END-EXEC.PERFORM NO LIMIT    EXEC SQL FETCH FROM cur1 INTO :A, :B END-EXEC    DISPLAY "a=" ARR OF A ", b=" ARR OF BEND-PERFORM.END-FETCH.EXEC SQL CLOSE cur1 END-EXEC.</pre><p>Another workaround is avoiding the direct use of the user-defined types in ECOBPG and instead create a function or cast that converts between the user-defined type and a primitive type that ECOBPG can handle. Note, however, that type casts, especially implicit ones, should be introduced into the type system very carefully.</p><p>For example:</p><pre class="border">CREATE FUNCTION create_complex(r double precision, i double precision) RETURNS complexLANGUAGE SQLIMMUTABLEAS $$ SELECT $1 * complex '(1,0)' + $2 * complex '(0,1)' $$;</pre><p>After this definition, the following:</p><pre class="border">EXEC SQL BEGIN DECLARE SECTION END-EXEC.01 A COMP-2.01 B COMP-2.01 C COMP-2.01 D COMP-2.EXEC SQL END DECLARE SECTION END-EXEC.MOVE 1 TO A.MOVE 2 TO B.MOVE 3 TO C.MOVE 4 TO D.EXEC SQL INSERT INTO test_complex VALUES (create_complex(:A, :B), create_complex(:C, :D)) END-EXEC.</pre><p>has the same effect as</p><pre class="border">EXEC SQL INSERT INTO test_complex VALUES ('(1,2)', '(3,4)') END-EXEC.</pre></div></div><div class="header_footer"><div class="back_next"><a href="j2681-d-04-04.html"><img src="image/back2.gif" width="65" height="27" border="0" alt="Previous" title="Previous"></a><a href="j2681-d-04-06.html"><img src="image/next2.gif" width="64" height="27" border="0" alt="Next" title="Next"></a></div><div class="copyright">Copyright 2015-2021 FUJITSU LIMITED</div></div></body></html>